# v0.10にアップグレードする

多くの部分でv0.9プロジェクトと単純にliftするだけで動作します。コアコントリビュータはアップグレードをできるかぎり簡単にするために多くのステップを踏んできましたのでコンソールのデプリケーションメッセージに従うだけで大丈夫です。

Sails v0.10には大きな変更点がいくつかあります。以下のセクションでは何が代わったの概要や大きなバグフィックス、改善、新機能とSails v0.90アプリケーションをSilas v0.10アプリケーションにアップグレードするための基本的なやり方を紹介します。

## ファイルアップロード

Connectマルチパートミドルウエアは[まもなく公式に廃止されます](http://www.senchalabs.org/connect/multipart.html)。しかし、Sails v0.9 と Express v3 の内臓のHTTPボディーパーサに利用されていたため`req.files`に依存していたSails 0.9プロジェクトにとってこれは大きな変更点になります。

v0.10ではデフォルトで[skipper](https://github.com/balderdashy/skipper)を内蔵していますがこれはストリーミングファイルアップロードをディスクへのバッファなしに実現します。通常のファイルアップロードのケースに関してSkipperは（skipper-diskを通じて）ローカルディスクへのアップロードの対応を内蔵していますが、ストリーミングアップロードはこれに対応するアダプタを通じて行う必要があります。

この例やドキュメンテーションに関してはSkipperのレポジトリの他にSailsの`req.file()`の項目をお読みください。

### どうしてでしょうか?

ボディパーサの役割はマルチパートのHTTPリクエストの"body"をパースすることです。時に"body"はテキストパラメータを含んでいることもありますが、ファイルアップロードを含んでいることもあります。

Connectは素晴らしいコードですし、マルチパートリクエストにおいてテキストパラメータとファイルアップロードの両方をサポートします。しかしこのような種類のモジュールの多くと同じようにディスクにファイルアップロードをバッファすることにより実現しています。これは簡単にディスクに容量を凌駕してしまい、多くのケースでDoS攻撃の脆弱性を晒すことになります。

Skipperは **ストリーミング** ファイルアップロードをサポートするという点において特徴的で、リクエストボディの中にあるメタデータ（すなわち、JSON/XML/urlencodedのようなリクエストボディパラメータです）も維持することが出来ます。これはヒューリスティックの利点を使ってプラグインやblobアダプタが意図したファイルのみを受け取るようにし、その他の（もしかしたら悪意を持った）ファイルは無視します。

> #### ** 重要**
> Skipperが動作するためには、ファイルアップロードをサーバにリクエストするにあたって _全てのテキストパラメータはファイルパラメータの前にインクルードされなければいけません_ 。Skipperは最初のファイルがアップロードされたと判断するとテキストパラメータを待ち受けるのをやめてしまいます。（これは危険で不要な、ファイル内容バッファを避けるための措置です。）

### 別のボディーパーサを設定する

Sailsの中の多くのものと同じように全てのConnect/Express/Sails対応をボディーパーサをお好みに合わせて使うことが出来ます。**connect-multipart** に戻したい場合や、別のボディーパーサ( **formidable** や **busboy** のような)を使いたい場合はアプリケーションのhttp設定を変えてください。

## ブループリント

新しいブループリントアクション(`findOne`)が追加されました。例えば、もし`FooController`と`Foo`があってそこに`/foo/5`へのリクエストが有った場合、`FooController`の`findOne`アクションが実行されます。もし`findOne`アクションがないときはブループリントアクションが代わりに実行されます。`/foo`に送られたリクエストは引き続きfindのコントローラアクションまたはブループリントアクションとして動作します。

## ポリシー

ポリシーはv0.9で動いていたのと全く同じように動きます。新たに想定しなければいけない状況があります。上に挙げたように`findOne()`ブループリントアクションが追加されたのでこれをポリシーマッピング設定で別個のものとして扱わなければなりません。

例えば`policies.js`で`DoveController`の`find`アクションへのアクセスを防いでいたSails v0.9アプリケーションがあるとしましょう。

```
module.exports.policies = {
  '*': true,
  DoveController: {
    find: false
  }
};
```

全てのブループリントルートが有効化されていると仮定すると、`/dove` と `/dove/14` の両方へのアクセスが防がれています。しかし、v0.10では`/dove/14`は実際には`findOne`を実行しますのでこれを別々に取り扱わなければなりません。:

```
module.exports.policies = {
  '*': true,
  DoveController: {
    find: false,
    findOne: false
  }
};
```

## Pubsub

### 概要
+ クライアントの`message`ソケット（すなわち、"comment"）イベントは`modelIdentity`になりました。(modelIdentityは度のモデルからメソッドが呼び出されるのかによって違います)
+ クライアントはもうblueprintルートのmodel-creationにサブスクライブされません。データ作成イベントをリッスンするには`Model.watch()`を使ってください。
+ かつて`create`、 `update`、`destroy`と命名されていたイベントは現在は`created`、`updated`、`destroyed`です。

### 詳細
最大の変更点はSocket.ioのイベントはモデル自身の名前の元に送信されるということになったことです。以前はクライアントは`message`イベントをリッスンしてそこに含まれているデータを元にどのモデルが送信していたかを判断していました。:

```
socket.on('message', function(cometEvent) {
   if (cometEvent.model == 'user') {
     // userレコードに関するインバウンドメッセージを扱う
   }
   else if (cometEvent.model === 'product') {
     // productレコードに関するインバウンドメッセージを扱う
   }
   // ...
}
```
現在はモデルの識別子にアクセスします。:
```
socket.on('user', function(cometEvent) {
  // userレコードに関するインバウンドメッセージを扱う
});

socket.on('product', function (cometEvent) {
  // productレコードに関するインバウンドメッセージを扱う
});
```
これはフロントエンドコードの構造化に役立ちます。

クライアントがモデルをサブスクライブする方法も変更されました。今まではそれがモデルクラスであっても、１つや複数のモデルインスタンスであっても`Model.subscribe`に渡されるパラメータを元にサブスクライブする対象を判断していました。これは事実上、一つのメソッドで二つの全く異なることをしていました。

今は`Model.subscribe()`をモデルインスタンス（レコード）をサブスクライブすることのみに使います。同様にリッスンしたいイベントの"contexts"やタイプを指定できます。例えばもしあるインスタンスのアップデートのみ、メッセージを受け取りたい場合は`User.subscribe(req, myUser, 'update')`をコールできます。もし`.subscribe()`を呼び出す際に何のコンテキストも与えられていない場合はモデルクラスのautosubscribeで指定された全てのコンテキストが使われます。

モデルの生成イベントをリッスンするには現在は`Model.watch()`が使えます。サブスクリプションすることによってクライアントはblueprintルートを使ってそのモデルにデータが生成される度にメッセージを受け取り、新しいインスタンスを自動的にリッスンします。

blueprintsを使っている時にクラスが自動的にサブスクライブすることはもう無いということを覚えておいてください。これは手動で行う必要があります。

最後に、全てのモデルからのpubsubメッセーをじ受け取りたい際は開発環境でのみ使える`firehose`と呼ばれるツールにアクセスでき、ここではモデルに発生する _全てのこと_ に関してメッセージがブロードキャストされます。

新しいpubsubの例をアクションの中で見るには[SailsChat](https://github.com/balderdashy/sailschat) をご覧ください。

## ライフサイクルコールバックへの引数は型キャストされます。

以前は`schema: true`をすることで`.create()`や`.update()`にモデルアトリビュートで期待されている以外のデータ型を渡した場合、それらの値はライフサイクルコールバックでアクセス可能でした。

Sails/Waterline v0.10ではもうすでにこの限りではありません。`.create()`と`.update()`に渡された値はライフサイクルコールバックがされる前に型キャストされます。`beforeUpdate()`と`beforeCreate()`と`beforeValidate()`の影響を受けるコールバックの範囲に入ります。

## beforeValidation() は beforeValidate() になりました

もし`beforeValidation`か`afterValidation`のモデルライフサイクルコールバックをモデルで使っていた場合それらを`beforeValidate`と`afterValidate`に変えなければなりません。これはWaterlineをその他のライフサイクルコールバック (`beforeCreate`, `afterUpdate`などのスタイルに合わせたためです)。

## .done() と .exec()

** 古い（あるいはややこしい？）意味の`.done()`はもはや廃止されました**

Sails <= v0.8ではORMを実行する文法は`Model. [ … ] .done( cb )`でした。v0.9ではpromiseのサポートが追加されpromiseの中で`.done()`が特別な意味を持つので`Model. [ … ] .exec( cb )`が推奨される代替方法になりました。しかし、v0.8 から v0.9への移行を簡単にするためにもともとの`.done()`の用法もそのままにしていました。

しかし、Sails/Waterline v0.10ではもっとしっかりしたpromiseの実装を進め、(`Q` や `Bluebird`などの)プラグイン可能なライブラリをサポートするために、もともとの意味の`.done()`は正式に廃止されました。

## アソシエーション

Sails v0.10ではデータモデル間のアソシエーションを導入しました。我々が加えた変更は主に付加的なものなので現存のモデルは以前としてただ動くでしょう。これはつまり、このパワフルな新機能は書くべきコードを少なくし、アプリケーションをさらにメンテナンス性の高いものにするのでこの利点を活かしましょうということです！Sailsでどのようにアソシエーションを使うかはドキュメントをご覧ください。

アソシエーション（あるいはリレーション）は単に特種なアトリビュートです。文字列や整数の代わりにモデルのインスタンスやそのコレクションを指定します。これはJSONやNoSQLデータベースに格納されるオブジェクト(`{...}`)や(`[{...}, {...}]`)のようなものと考えていただいても良いでしょう。違いは、Sailsではサポートしているすべてのデータベースと動作することができ、しかも異なるデータベースや異なる種類のデータベースをまたいでpopulate（すなわちJSON）することが出来るということです。

## ジェネレータ

Sailはコードの自動生成 (例： `sails generate controller foo`) をサポートしますが、v0.10ではこの機能を更に拡張可能に、Sailsコミュニティの誰にでもオープンにアクセス可能にしたいと考えました。このような考え方のもとv0.10ではコマンドラインツールとプラグイン可能なジェネレータをを完全に書き換えました。`sails generate blog foo`を使って新しいブログをSailsで作りたいでしょうか。それなら(`generate generator blog`を実行して)`blog`ジェネレータを作ってテンプレートを追加し、テンプレートを書き換えるための設定を行ってください。それからnpmのコマンドを使って、`sails-generate-blog`と命名されたこのモジュールをコミュニティーに向けて公開できます。Yomanジェネレータとの互換性機能も予定されています。

## コマンドラインツール

ここでの大きな変更点は新しいAPIの作り方です。かつては`sails generate new_api`をコールしていました。これによって`new_api`と呼ばれるモデルとコントローラを適切な位置に生成できます。現在はこれを`sails generate api new_api`で行うことが出来ます。

同じCLIのコマンドを使ってモデルとコントローラを別々に生成することも出来ます。

同様に、`--linker`スイッチはもう使えません。以前のバージョンでは `--linker`を提供されていれば`js`、`styles`と`templates`フォルダが入っている`myApp/assets/linker`フォルダーを生成しました。新しいバージョンでは`myApp/assets/linker`フォルダーは生成されません。`myApp/assets/js`と`myApp/assets/scripts`フォルダでのCoffeeScriptとLessのコンパイルは最初から標準の動作になりました、

## カスタムサーバレスポンス

v0.10ではカスタムのサーバレスポンスを生成できます。

以前と同じように幾つかのものは自動生成されます。`myApp/config/500.js`などの`.js`レスポンスをコンフィグディレクトリで生成する代わりに今では`myApp/api/responses/`に生成されます。

マイグレーションするには新しいv0.10プロジェクトを作って`myApp/api/responses`ディレクトリを既存のアプリケーションにコピーします。それから、レスポンスロジックファイル(500.jsなど)をあなたが行ったカスタマイズに対応するように適切な.jsファイルを編集します。

## レガシーなデータはsails-diskの一時データベースに保管されます。

新しいSailsプロジェクトでデフォルトで使われる`sails-disk`では少し違った方法でデータを格納します。もし0.9.xのプロジェクトで保存された一時的データがある場合、それらを削除して新しく始める必要があります。これを行うには:

プロジェクトのルートディレクトリで:

```
$ rm .tmp/disk.db
```

## アダプタとデータベースの設定

`config.adapters`(`myApp/config/adapters.js`にあります)はconfig.connections(新規のプロジェクトでは`myApp/config/connections.js`に生成されます)になりました。同じく`config.model`は現在は`config.models`です。

アプリケーションのデフォルトの`connection`（つまりデータベース）はこれからは`config.models.connection`で設定されなければならず、これらモデルでデフォルトとして使われます。新規プロジェクトは`/config/models.js`ファイルで生成され、デフォルトのコネクションを含みます。

特定のアダプタを指定したい場合は`adapters`の代わりに`connection`キーで設定しなければなりません。

例:
```
module.exports = {

    connection: ['someMongoDatabase'],

    attributes: {
        name:{
            type     : 'string',
            required : true
        }
    }
};
```

## Blueprints/Controller設定

コントローラのブループリントを上書きするコントローラ設定のオブジェクトリテラルは以下のように変更されなければいけません。:
```
...
_config: {
  blueprints: {
    rest: true,
    ...
  }
}
```
変更後:
```
...
_config: {
    rest: true,
    ...
}
```

## レイアウトパス:
Sails v0.9ではビューをレンダリングする際のカスタムレイアウトとして`auth/someLayout.ejs`を指定するためには以下の構文を使わなければなりません。:
```
return res.view('auth/login',{
  layout: 'someLayout'
});
```
しかし、Sails v0.10では全てのレイアウトパスはアプリケーションのビューのパスに対して相対的です。言い換えれば、レイアウトのの相対パスはビューのパス自身によって解決されなくなり、常にビューのパスで解決されるということです。これは特に同じような名前を持つレイアウトファイルでこのファイルが利用されるのかを理解するのに役立ちます。:
```
return res.view('auth/login', {
  layout: 'auth/someLayout'
});
```


<docmeta name="displayName" value="To v.0.10">
